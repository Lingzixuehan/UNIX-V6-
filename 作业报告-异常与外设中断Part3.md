# 作业7 Part 3：Unix V6++ 系统异常处理实现

**课程**: 操作系统
**学校**: 同济大学计算机系
**班级**: 拔尖班2023

---

## 一、作业要求

Part 3 是思考题（总评分加5分），要求在 Unix V6++ 系统中复现除零异常处理程序。具体要求：

1. 实现一个除法计算程序
2. 当输入除数为 0 时，能够捕获并处理 SIGFPE 信号
3. 程序不会因为除零异常而崩溃，而是能够继续运行
4. 演示异常响应的完整过程

---

## 二、实现方案

### 2.1 信号处理机制分析

Unix V6++ 系统已经实现了基本的信号处理机制：

1. **信号定义**：在 `src/lib/include/sys.h` 中定义了完整的信号集
   - SIGFPE (信号编号 8)：浮点异常/除零异常
   - SIGINT (信号编号 2)：键盘中断
   - SIGKILL (信号编号 9)：强制终止等

2. **系统调用**：
   ```c
   int signal(int signal, void (*func)());
   ```
   - 用于注册信号处理函数
   - 在 Unix V6 中，signal() 是一次性的
   - 必须在处理函数中重新注册

3. **信号处理函数规范**：
   - 必须接受 int 类型参数（信号编号）
   - 返回值为 void
   - 需要重新注册以继续捕获同类信号

### 2.2 程序设计

创建 `divzero.c` 程序，实现以下功能：

#### 2.2.1 信号处理函数

```c
void sig_dzero(int signo)
{
    if (signo == SIGFPE)
    {
        printf("\n[!] Caught SIGFPE: Division by zero detected!\n");
        printf("Can't divide by zero!\n");
        // 重新注册信号处理函数（Unix V6 特性）
        signal(SIGFPE, sig_dzero);
    }
}
```

#### 2.2.2 主程序流程

1. 注册 SIGFPE 信号处理函数
2. 进入主循环
3. 接收用户输入的被除数 a 和除数 b
4. 执行除法运算 c = a / b
5. 如果 b = 0，触发 SIGFPE 信号
6. 信号处理函数捕获异常并输出错误信息
7. 程序继续运行，等待下一次输入

#### 2.2.3 完整代码

程序位置：`src/program/divzero.c`

关键特性：
- 使用 `signal(SIGFPE, sig_dzero)` 注册异常处理函数
- 在信号处理函数中重新注册（Unix V6 特性）
- 主循环持续运行，不会因异常而退出
- 提供友好的用户交互界面

### 2.3 编译配置

修改 `src/program/Makefile`，添加 divzero 程序的编译规则：

1. 在 `SHELL_OBJS` 中添加：
   ```makefile
   $(TARGET)\divzero.exe
   ```

2. 添加编译规则：
   ```makefile
   $(TARGET)\divzero.exe : divzero.c
       $(CC) $(CFLAGS) -I"$(INCLUDE)" -I"$(LIB_INCLUDE)" $< -e _main1 $(V6++LIB) -o $@
       copy $(TARGET)\divzero.exe $(MAKEIMAGEPATH)\$(BIN)\divzero
   ```

---

## 三、异常处理过程分析

### 3.1 正常除法流程

```
用户输入: a=10, b=2
   ↓
执行: c = a / b
   ↓
计算结果: c = 5
   ↓
输出: "Result: 10 / 2 = 5"
   ↓
继续等待下一次输入
```

### 3.2 除零异常处理流程

```
1. 用户输入: a=10, b=0
   ↓
2. 执行: c = a / b
   ↓
3. CPU 检测到除零操作
   ↓
4. 硬件触发除零异常（#DE - Divide Error）
   ↓
5. CPU 保存现场：
   - 将用户态寄存器压入用户栈
   - 切换到核心态
   - 将中断返回地址、CS、EFLAGS 等压入核心栈
   ↓
6. 通过 IDT（中断描述符表）查找异常处理入口
   ↓
7. 进入内核异常处理函数
   ↓
8. 内核识别为除零异常（Exception #0）
   ↓
9. 内核将异常转换为 SIGFPE 信号
   ↓
10. 检查当前进程的信号处理表
    ↓
11. 发现用户注册了 SIGFPE 处理函数
    ↓
12. 设置用户栈，准备调用用户态信号处理函数：
    - 保存当前上下文到用户栈
    - 设置返回地址为信号处理函数
    ↓
13. 从核心态返回用户态
    ↓
14. 执行用户信号处理函数 sig_dzero()：
    - 输出错误信息
    - 重新注册信号处理函数
    ↓
15. 信号处理函数返回
    ↓
16. 恢复用户程序上下文
    ↓
17. 从触发异常的下一条指令继续执行
    ↓
18. 程序继续运行，等待下一次输入
```

### 3.3 用户栈与核心栈的变化

#### 除零异常发生时：

**用户栈**（用户态）：
```
高地址
+------------------+
| 局部变量 (a,b,c) |
+------------------+
| 返回地址         |
+------------------+
| 保存的 ebp       |
+------------------+ ← 当前 esp (用户栈顶)
低地址
```

**核心栈**（切换到核心态后）：
```
高地址
+------------------+
| SS (用户栈段)    |
+------------------+
| ESP (用户栈顶)   |
+------------------+
| EFLAGS           |
+------------------+
| CS (用户代码段)  |
+------------------+
| EIP (异常指令)   |
+------------------+
| Error Code (可选)|
+------------------+ ← 核心栈顶
低地址
```

#### 调用信号处理函数时：

**用户栈**（准备调用信号处理函数）：
```
高地址
+------------------+
| 保存的上下文     |
+------------------+
| 返回地址         |
+------------------+
| 信号编号 (8)     | ← 信号处理函数的参数
+------------------+ ← 新的 esp
| 局部变量 (a,b,c) |
+------------------+
低地址
```

---

## 四、与 Ubuntu 系统的对比

### 4.1 相同点

1. **异常触发机制**：都是由 CPU 硬件检测除零操作并触发异常
2. **信号转换**：内核都将硬件异常转换为 SIGFPE 信号
3. **用户态处理**：都允许用户程序注册信号处理函数
4. **栈切换**：都涉及用户栈和核心栈的切换

### 4.2 差异点

| 特性 | Unix V6++ | Ubuntu (现代 Linux) |
|------|-----------|---------------------|
| 信号注册 | 一次性，需重新注册 | 持久性注册 |
| 系统调用 | `signal()` | `signal()` 或 `sigaction()` |
| 信号处理函数原型 | `void func(int)` | `void func(int)` 或带额外参数 |
| 信号掩码 | 简单的信号处理 | 支持复杂的信号掩码和阻塞 |
| 可靠性 | 可能丢失信号 | 可靠信号机制 |
| 信号队列 | 不支持 | 支持实时信号队列 |

### 4.3 Unix V6 的特殊性

1. **一次性信号处理**：
   - 信号处理函数执行后，自动恢复为默认行为
   - 必须在处理函数内重新注册
   - 这是早期 Unix 系统的设计特点

2. **简化的信号机制**：
   - 信号处理相对简单
   - 没有复杂的信号掩码和阻塞机制
   - 适合教学和理解基本原理

---

## 五、程序使用说明

### 5.1 编译

在 Unix V6++ 系统中：
```bash
cd src/program
make divzero.exe
```

### 5.2 运行

```
# 启动程序
> divzero

Division Exception Handler Test Program
========================================
This program demonstrates SIGFPE signal handling.
Enter two integers for division. Enter 0 0 to exit.

Enter dividend a: 10
Enter divisor b: 2
Result: 10 / 2 = 5

Enter dividend a: 10
Enter divisor b: 0

[!] Caught SIGFPE: Division by zero detected!
Can't divide by zero!

Enter dividend a: 8
Enter divisor b: 4
Result: 8 / 4 = 2

Enter dividend a: 0
Enter divisor b: 0
Exiting program...
```

### 5.3 测试要点

1. **正常除法**：输入正常的被除数和除数，验证计算正确
2. **除零异常**：输入除数为 0，验证异常被捕获
3. **多次除零**：多次输入除数为 0，验证信号重新注册成功
4. **程序持续性**：验证程序在异常后能继续运行
5. **退出功能**：输入 0 0 正常退出程序

---

## 六、技术要点总结

### 6.1 信号处理的关键步骤

1. **注册信号处理函数**：
   ```c
   signal(SIGFPE, sig_dzero);
   ```

2. **实现信号处理函数**：
   ```c
   void sig_dzero(int signo) {
       // 处理异常
       // 重新注册（Unix V6 特性）
       signal(SIGFPE, sig_dzero);
   }
   ```

3. **触发异常**：
   ```c
   c = a / b;  // 当 b = 0 时触发 SIGFPE
   ```

### 6.2 Unix V6++ 信号机制特点

1. **一次性注册**：与现代 Linux 的持久性注册不同
2. **必须重新注册**：在处理函数中调用 signal() 重新注册
3. **简洁的 API**：只有基本的 signal() 和 kill() 系统调用
4. **教学价值**：清晰展示信号处理的基本原理

### 6.3 异常处理的意义

1. **程序健壮性**：避免因异常输入导致程序崩溃
2. **用户体验**：提供友好的错误提示
3. **系统稳定性**：防止单个进程异常影响整个系统
4. **错误恢复**：允许程序从错误状态恢复并继续运行

---

## 七、实验收获

1. **深入理解异常处理机制**：
   - 从硬件异常触发到软件信号处理的完整流程
   - 用户态和核心态的切换过程
   - 栈的切换和上下文保存恢复

2. **Unix V6 系统特性**：
   - 一次性信号注册机制
   - 简洁的系统调用接口
   - 与现代 Linux 的异同

3. **实践能力提升**：
   - 在真实操作系统中实现信号处理
   - 理解系统调用的使用方法
   - 掌握异常处理的编程技巧

4. **系统设计思想**：
   - 分层设计：硬件异常 → 内核处理 → 用户处理
   - 灵活性：允许用户自定义异常处理行为
   - 简洁性：Unix V6 的设计哲学

---

## 八、参考资料

1. Unix V6++ 源代码：`src/lib/include/sys.h`
2. 信号处理示例：`src/program/immortal.c`, `src/program/sigTest.c`
3. 操作系统课程讲义：异常与中断处理
4. UNIX V6 源代码注释
