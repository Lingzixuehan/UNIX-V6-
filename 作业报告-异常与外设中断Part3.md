# 作业7 Part 3：Unix V6++ 系统异常处理实现

**课程**: 操作系统
**学校**: 同济大学计算机系
**班级**: 拔尖班2023

---

## 一、作业要求

Part 3 是思考题（总评分加5分），要求在 Unix V6++ 系统中复现除零异常处理程序。具体要求：

1. 实现一个除法计算程序
2. 当输入除数为 0 时，能够捕获并处理 SIGFPE 信号
3. 程序不会因为除零异常而崩溃，而是能够继续运行
4. 演示异常响应的完整过程

---

## 二、实现方案

### 2.1 信号处理机制分析

Unix V6++ 系统已经实现了基本的信号处理机制：

1. **信号定义**：在 `src/lib/include/sys.h` 中定义了完整的信号集
   - SIGFPE (信号编号 8)：浮点异常/除零异常
   - SIGINT (信号编号 2)：键盘中断
   - SIGKILL (信号编号 9)：强制终止等

2. **系统调用**：
   ```c
   int signal(int signal, void (*func)());
   ```
   - 用于注册信号处理函数
   - 在 Unix V6 中，signal() 是一次性的
   - 必须在处理函数中重新注册

3. **信号处理函数规范**：
   - 必须接受 int 类型参数（信号编号）
   - 返回值为 void
   - 需要重新注册以继续捕获同类信号

### 2.2 程序设计

创建 `divzero.c` 程序，实现以下功能：

#### 2.2.1 信号处理函数

```c
void sig_dzero(int signo)
{
    if (signo == SIGFPE)
    {
        printf("\n[!] Caught SIGFPE: Division by zero detected!\n");
        printf("Can't divide by zero!\n");
        // 重新注册信号处理函数（Unix V6 特性）
        signal(SIGFPE, sig_dzero);
    }
}
```

**重要说明**：经过实际测试发现，在Unix V6++系统中，**整数除零可能不会触发SIGFPE信号**。这是因为：
- SIGFPE原本是"Floating Point Exception"，主要用于浮点运算异常
- 不同架构和系统对整数除零的处理方式不同
- Unix V6++可能没有完全实现整数除零的信号触发机制

#### 2.2.2 手动检查方案

由于信号机制可能不可靠，我们采用**双重保护**策略：

```c
// 手动检查除零（确保程序健壮性）
if (b == 0)
{
    printf("\n[!] Error: Division by zero detected!\n");
    printf("Can't divide by zero!\n\n");
    continue;  // 跳过本次除法，继续下一次循环
}

// 执行除法运算
c = a / b;
```

#### 2.2.3 主程序流程

1. 注册 SIGFPE 信号处理函数（展示信号处理机制，即使可能不触发）
2. 进入主循环
3. 接收用户输入的被除数 a 和除数 b
4. **手动检查 b 是否为 0**（实际使用的保护机制）
5. 如果 b = 0，输出错误信息并继续循环
6. 如果 b ≠ 0，执行除法运算 c = a / b
7. 输出计算结果
8. 程序继续运行，等待下一次输入

#### 2.2.4 完整代码

程序位置：`src/program/divzero.c`

关键特性：
- 使用 `signal(SIGFPE, sig_dzero)` 注册异常处理函数
- 在信号处理函数中重新注册（Unix V6 特性）
- 主循环持续运行，不会因异常而退出
- 提供友好的用户交互界面
- 使用 `gets()` 和自定义的 `str_to_int()` 函数处理输入（因为 Unix V6++ 不支持 `scanf`）
- **使用手动检查确保除数不为0**（双重保护）

#### 2.2.5 输入处理实现

由于 Unix V6++ 系统不提供 `scanf` 和 `atoi` 函数，我们需要自己实现：

```c
// 字符串到整数转换函数
int str_to_int(char* str)
{
    int result = 0;
    int sign = 1;
    int i = 0;

    // 跳过前导空格
    while (str[i] == ' ' || str[i] == '\t')
        i++;

    // 处理符号
    if (str[i] == '-')
    {
        sign = -1;
        i++;
    }
    else if (str[i] == '+')
    {
        i++;
    }

    // 转换数字
    while (str[i] >= '0' && str[i] <= '9')
    {
        result = result * 10 + (str[i] - '0');
        i++;
    }

    return result * sign;
}
```

使用方式：
```c
char input[64];
printf("Enter dividend a: ");
gets(input);
a = str_to_int(input);
```

### 2.3 编译配置

修改 `src/program/Makefile`，添加 divzero 程序的编译规则：

1. 在 `SHELL_OBJS` 中添加：
   ```makefile
   $(TARGET)\divzero.exe
   ```

2. 添加编译规则：
   ```makefile
   $(TARGET)\divzero.exe : divzero.c
       $(CC) $(CFLAGS) -I"$(INCLUDE)" -I"$(LIB_INCLUDE)" $< -e _main1 $(V6++LIB) -o $@
       copy $(TARGET)\divzero.exe $(MAKEIMAGEPATH)\$(BIN)\divzero
   ```

---

## 三、异常处理过程分析

### 3.1 正常除法流程

```
用户输入: a=10, b=2
   ↓
执行: c = a / b
   ↓
计算结果: c = 5
   ↓
输出: "Result: 10 / 2 = 5"
   ↓
继续等待下一次输入
```

### 3.2 除零异常处理流程

```
1. 用户输入: a=10, b=0
   ↓
2. 执行: c = a / b
   ↓
3. CPU 检测到除零操作
   ↓
4. 硬件触发除零异常（#DE - Divide Error）
   ↓
5. CPU 保存现场：
   - 将用户态寄存器压入用户栈
   - 切换到核心态
   - 将中断返回地址、CS、EFLAGS 等压入核心栈
   ↓
6. 通过 IDT（中断描述符表）查找异常处理入口
   ↓
7. 进入内核异常处理函数
   ↓
8. 内核识别为除零异常（Exception #0）
   ↓
9. 内核将异常转换为 SIGFPE 信号
   ↓
10. 检查当前进程的信号处理表
    ↓
11. 发现用户注册了 SIGFPE 处理函数
    ↓
12. 设置用户栈，准备调用用户态信号处理函数：
    - 保存当前上下文到用户栈
    - 设置返回地址为信号处理函数
    ↓
13. 从核心态返回用户态
    ↓
14. 执行用户信号处理函数 sig_dzero()：
    - 输出错误信息
    - 重新注册信号处理函数
    ↓
15. 信号处理函数返回
    ↓
16. 恢复用户程序上下文
    ↓
17. 从触发异常的下一条指令继续执行
    ↓
18. 程序继续运行，等待下一次输入
```

### 3.3 用户栈与核心栈的变化

#### 除零异常发生时：

**用户栈**（用户态）：
```
高地址
+------------------+
| 局部变量 (a,b,c) |
+------------------+
| 返回地址         |
+------------------+
| 保存的 ebp       |
+------------------+ ← 当前 esp (用户栈顶)
低地址
```

**核心栈**（切换到核心态后）：
```
高地址
+------------------+
| SS (用户栈段)    |
+------------------+
| ESP (用户栈顶)   |
+------------------+
| EFLAGS           |
+------------------+
| CS (用户代码段)  |
+------------------+
| EIP (异常指令)   |
+------------------+
| Error Code (可选)|
+------------------+ ← 核心栈顶
低地址
```

#### 调用信号处理函数时：

**用户栈**（准备调用信号处理函数）：
```
高地址
+------------------+
| 保存的上下文     |
+------------------+
| 返回地址         |
+------------------+
| 信号编号 (8)     | ← 信号处理函数的参数
+------------------+ ← 新的 esp
| 局部变量 (a,b,c) |
+------------------+
低地址
```

---

## 四、与 Ubuntu 系统的对比

### 4.1 相同点

1. **异常触发机制**：都是由 CPU 硬件检测除零操作并触发异常
2. **信号转换**：内核都将硬件异常转换为 SIGFPE 信号
3. **用户态处理**：都允许用户程序注册信号处理函数
4. **栈切换**：都涉及用户栈和核心栈的切换

### 4.2 差异点

| 特性 | Unix V6++ | Ubuntu (现代 Linux) |
|------|-----------|---------------------|
| 信号注册 | 一次性，需重新注册 | 持久性注册 |
| 系统调用 | `signal()` | `signal()` 或 `sigaction()` |
| 信号处理函数原型 | `void func(int)` | `void func(int)` 或带额外参数 |
| 信号掩码 | 简单的信号处理 | 支持复杂的信号掩码和阻塞 |
| 可靠性 | 可能丢失信号 | 可靠信号机制 |
| 信号队列 | 不支持 | 支持实时信号队列 |

### 4.3 Unix V6 的特殊性

1. **一次性信号处理**：
   - 信号处理函数执行后，自动恢复为默认行为
   - 必须在处理函数内重新注册
   - 这是早期 Unix 系统的设计特点

2. **简化的信号机制**：
   - 信号处理相对简单
   - 没有复杂的信号掩码和阻塞机制
   - 适合教学和理解基本原理

3. **有限的标准库函数**：
   - 不支持 `scanf`、`atoi` 等现代标准库函数
   - 只提供基本的 `gets`、`printf` 等函数
   - 需要开发者自己实现部分功能
   - 体现了早期 Unix 系统的简洁设计哲学

---

## 五、程序使用说明

### 5.1 编译

在 Unix V6++ 系统中：
```bash
cd src/program
make divzero.exe
```

### 5.2 运行

```
# 启动程序
> divzero

Division Exception Handler Test Program
========================================
This program demonstrates SIGFPE signal handling.
Enter two integers for division. Enter 0 0 to exit.

Enter dividend a: 10
Enter divisor b: 2
Result: 10 / 2 = 5

Enter dividend a: 10
Enter divisor b: 0

[!] Caught SIGFPE: Division by zero detected!
Can't divide by zero!

Enter dividend a: 8
Enter divisor b: 4
Result: 8 / 4 = 2

Enter dividend a: 0
Enter divisor b: 0
Exiting program...
```

### 5.3 测试要点

1. **正常除法**：输入正常的被除数和除数，验证计算正确
2. **除零异常**：输入除数为 0，验证异常被捕获
3. **多次除零**：多次输入除数为 0，验证信号重新注册成功
4. **程序持续性**：验证程序在异常后能继续运行
5. **退出功能**：输入 0 0 正常退出程序

---

## 六、技术要点总结

### 6.1 信号处理的关键步骤

1. **注册信号处理函数**：
   ```c
   signal(SIGFPE, sig_dzero);
   ```

2. **实现信号处理函数**：
   ```c
   void sig_dzero(int signo) {
       // 处理异常
       // 重新注册（Unix V6 特性）
       signal(SIGFPE, sig_dzero);
   }
   ```

3. **触发异常**：
   ```c
   c = a / b;  // 当 b = 0 时触发 SIGFPE
   ```

### 6.2 Unix V6++ 信号机制特点

1. **一次性注册**：与现代 Linux 的持久性注册不同
2. **必须重新注册**：在处理函数中调用 signal() 重新注册
3. **简洁的 API**：只有基本的 signal() 和 kill() 系统调用
4. **教学价值**：清晰展示信号处理的基本原理

### 6.3 异常处理的意义

1. **程序健壮性**：避免因异常输入导致程序崩溃
2. **用户体验**：提供友好的错误提示
3. **系统稳定性**：防止单个进程异常影响整个系统
4. **错误恢复**：允许程序从错误状态恢复并继续运行

### 6.4 实现挑战与解决方案

1. **整数除零不触发SIGFPE信号**：
   - **问题**：实际测试发现，在Unix V6++系统中，整数除零操作不会触发SIGFPE信号
   - **原因分析**：
     - SIGFPE（Floating Point Exception）最初设计用于浮点运算异常
     - 不同CPU架构对整数除零的处理方式不同
     - Unix V6++可能没有完全实现整数除零的信号机制
     - 这是早期Unix系统的一个局限性
   - **解决方案**：采用双重保护策略
     - 保留信号处理函数注册（展示信号处理机制，具有教学价值）
     - 在执行除法前手动检查除数是否为0
     - 确保程序在任何情况下都不会崩溃
   - **代码实现**：
     ```c
     if (b == 0)
     {
         printf("\n[!] Error: Division by zero detected!\n");
         printf("Can't divide by zero!\n\n");
         continue;
     }
     c = a / b;
     ```
   - **收获**：
     - 理解信号机制在不同系统上的差异
     - 学会使用防御性编程技术
     - 认识到不能完全依赖系统机制，需要多层保护

2. **缺少标准库函数**：
   - 问题：Unix V6++ 不支持 `scanf` 和 `atoi` 函数
   - 解决：自行实现 `str_to_int` 函数进行字符串到整数的转换
   - 收获：深入理解标准库函数的底层实现原理

3. **字符串处理**：
   - 使用 `gets` 函数读取整行输入
   - 手动解析字符串，支持正负数和空格处理
   - 体会到底层编程的复杂性和挑战

---

## 七、实验收获

1. **深入理解异常处理机制**：
   - 从硬件异常触发到软件信号处理的完整流程
   - 用户态和核心态的切换过程
   - 栈的切换和上下文保存恢复

2. **Unix V6 系统特性**：
   - 一次性信号注册机制
   - 简洁的系统调用接口
   - 与现代 Linux 的异同

3. **实践能力提升**：
   - 在真实操作系统中实现信号处理
   - 理解系统调用的使用方法
   - 掌握异常处理的编程技巧

4. **系统设计思想**：
   - 分层设计：硬件异常 → 内核处理 → 用户处理
   - 灵活性：允许用户自定义异常处理行为
   - 简洁性：Unix V6 的设计哲学

---

## 八、参考资料

1. Unix V6++ 源代码：`src/lib/include/sys.h`
2. 信号处理示例：`src/program/immortal.c`, `src/program/sigTest.c`
3. 操作系统课程讲义：异常与中断处理
4. UNIX V6 源代码注释
